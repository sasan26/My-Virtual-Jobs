'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.encrypt = encrypt;
exports.decrypt = decrypt;
exports.hash = hash;
exports.bcrypt = bcrypt;
exports.random = random;

require('babel-polyfill');

var _crypto = require('crypto');

var _crypto2 = _interopRequireDefault(_crypto);

var _bcryptjs = require('bcryptjs');

var _bcryptjs2 = _interopRequireDefault(_bcryptjs);

var _denodeify = require('denodeify');

var _denodeify2 = _interopRequireDefault(_denodeify);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

module.exports = _extends(_crypto2.default, {
  encrypt: encrypt, decrypt: decrypt, hash: hash, bcrypt: bcrypt, random: random
});

function encrypt(value, key) {
  if (typeof value === 'number') value = String(value);else if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') value = JSON.stringify(value);else if (typeof value !== 'string') return;

  key = key || process.env.ENCRYPTION_KEY;
  if (!key) throw new Error('you need an encryption key!');

  var cipher = _crypto2.default.createCipher('aes-256-ctr', key);
  var encrypted = cipher.update(value, 'utf8', 'hex');
  encrypted += cipher.final('hex');

  return encrypted;
}

function decrypt(value, key) {
  if (typeof value !== 'string') return;

  key = key || process.env.ENCRYPTION_KEY;

  var decipher = _crypto2.default.createDecipher('aes-256-ctr', key);
  var decrypted = decipher.update(value, 'hex', 'utf8');
  decrypted += decipher.final('utf8');

  if (decrypted.indexOf('{') === 0) {
    decrypted = JSON.parse(decrypted);
  }

  return decrypted;
}

function hash(value) {
  var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

  options.salt = options.salt || undefined;
  options.algorithm = options.algorithm || 'sha256';

  if (options.salt) value += options.salt;

  return _crypto2.default.createHash(options.algorithm).update(value).digest('hex');
}

function bcrypt(value, hash) {
  if (hash) {
    return (0, _denodeify2.default)(_bcryptjs2.default.compare)(value, hash);
  } else {
    return (0, _denodeify2.default)(_bcryptjs2.default.genSalt)(10).then(function (salt) {
      return (0, _denodeify2.default)(_bcryptjs2.default.hash)(value, salt);
    });
  }
}

function random() {
  var size = arguments.length <= 0 || arguments[0] === undefined ? 32 : arguments[0];

  if (size === 0) {
    throw new Error('zero-length randomHex is useless');
  }

  if (size % 2 !== 0) {
    throw new Error('randomHex size must be even');
  }

  return (0, _crypto.randomBytes)(size / 2).toString('hex');
}
//# sourceMappingURL=index.js.map